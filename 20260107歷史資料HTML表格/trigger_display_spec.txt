歷史觸發說明欄位顯示規格書
========================================

1. 功能概述
----------------------------------------
本功能旨在將「觸發說明」欄位的原始 JSON 資料（如 {'12/22': '-', '12/23': '二'}）
轉換為視覺化的 HTML 表格，並依照時間序排列，自動補齊漏掉的交易日，且根據條款內容上色。

2. 資料處理邏輯
----------------------------------------

### 2.1 資料來源解析
- 來源欄位: `trigger_info`
- 格式支援: JSON 字串 (String) 或 字典 (Dict)
- 若解析失敗或為空，回退顯示原始字串。

### 2.2 日期處理 (DateUtils)
- **輸入**: 鍵值為 "MM/DD" 格式的字串 (例如 "12/31", "01/05")
- **轉換邏輯**:
  1. 將 "MM/DD" 拆解為月份與日期。
  2. **跨年判斷**:
     - 取得當前年份 (Current Year)。
     - 若 `Month > 6` 且 `Current Month <= 6`，判定該日期為**去年** (Year - 1)。
     - 否則為**今年** (Year)。
  3. 轉換為 Python `datetime` 物件以便排序。
- **排序**: 由舊到新 (Ascending)。

### 2.3 顯示範圍過濾 (Smart Trimming)
- **目的**: 避免顯示開頭無意義的空紀錄 (例如連續多天的 "-")。
- **邏輯**:
  1. 遍歷排序後的日期清單。
  2. 找到第一個**有實質內容** (非 "-" 且非空) 的日期索引，設為 `start_idx`。
  3. 設定 `min_date` = `dates[start_idx]`。
  4. 設定 `max_date` = `dates[-1]` (最後一天)。

### 2.4 補齊交易日 (Gap Filling)
- **工具**: 需使用 `core.utils.DateUtils` 的 `is_trading_day()` 方法。
- **邏輯**:
  1. 從 `min_date` 迭代至 `max_date`。
  2. 對每一天檢查是否為交易日。
  3. **若為交易日**:
     - 將其加入最終顯示清單。
     - 若原始資料中有該日期的條款，則使用之。
     - 若無，則預設為 "-"。
     - (容錯: 同時嘗試匹配 "M/D" 與 "MM/DD" 格式的 Key)。

3. UI 呈現樣式 (HTML/RichText)
----------------------------------------

### 3.1 表格結構
使用 HTML `<table>` 標籤，透過 QLabel 的 RichText 模式渲染。

- **CSS 樣式**:
  - `border-collapse: collapse`
  - `text-align: center`
  - `background-color: #1E1E1E` (深色背景)

### 3.2 表頭 (日期行)
- **標籤**: `<th>`
- **樣式**:
  - `border: 1px solid #555`
  - `padding: 4px`
  - `color: #BBB` (淺灰色文字)
  - `font-size: 11px`

### 3.3 內容 (條款行)
- **標籤**: `<td>`
- **樣式**:
  - `border: 1px solid #555`
  - `padding: 6px`
  - `font-weight: bold`
  - `font-size: 12px`

### 3.4 顏色邏輯 (依內容判定)
1. **紅色警示**:
   - 條件: 內容包含 "一" (處置條款一)
   - 顏色: `#FF4444`
2. **一般條款**:
   - 條件: 內容非空 且 不等於 "-"
   - 顏色: `#4da6ff` (亮藍色)
3. **無觸發**:
   - 條件: 內容為 "-" 或 空
   - 顏色: `#555` (深灰色)

4. 程式實作注意事項
----------------------------------------

### 4.1 欄寬設定
- `QTableWidget` 的該欄位 (`Trigger Info`) 應設定為 **Fixed** 模式。
- **寬度**: `420px` (適合顯示約 5-10 天的歷史紀錄)。

### 4.2 避免 UnboundLocalError
- 由於 `DateUtils` 可能在全域被 import，若在函數內有隱式參照可能會導致錯誤。
- **解決方案**: 建議在 `load_items` 函數的第一行顯式 import:
  ```python
  def load_items(self):
      from core.utils import DateUtils  # 強制載入，避免 Scope 問題
      # ...
  ```

5. 範例程式碼片段
----------------------------------------
```python
# 1. 找出第一個有實質觸發內容的日期索引
start_idx = 0
for i, (d_str, dt) in enumerate(date_objects):
    val = clauses_map.get(d_str, "-")
    if val and val != "-" and val.strip():
        start_idx = i
        break

# 2. 補齊中間交易日
curr = min_date
while curr <= max_date:
    if DateUtils.is_trading_day(curr):
        # ... logic to get val ...
        final_dates.append((d_str, val))
    curr += timedelta(days=1)
```
