
class DispositionPredictor:
    @staticmethod
    def analyze(history_items, future_days=5):
        """
        history_items: list of dict [{"is_clause1": bool, "is_any": bool}, ...] 
                       Current day is LAST item.
        future_days: number of future days to simulate (e.g. 5)
        
        Returns: Warning string
        """
        if not history_items: return ""
        
        # Normalize Data
        H = []
        has_any_hit = False
        for item in history_items:
            c1 = item.get("is_clause1", False)
            any_c = item.get("is_any", False)
            if c1 or any_c: has_any_hit = True
            H.append({ "c1": c1, "any": any_c })
            
        # If no hits in entire history, prediction is just "If you start today...", which is noise.
        # Unless the user wants to know they are safe? Default is silent.
        # But wait, Rule 3 uses a 10-day window. If history is [0,0,0], Base=0. Next 6 days trigger.
        # User implies this is spam.
        if not has_any_hit:
            return ("", 0)

        candidates = [] # List of {"days": int, "msg": str, "type": "C1"|"Any"}
        
        # Rule 1: Consecutive 3 days Clause 1
        streak_c1 = 0
        for i in range(len(H)-1, -1, -1):
            if H[i]["c1"]: streak_c1 += 1
            else: break
            
        needed_c1 = 3 - streak_c1
        if needed_c1 <= 0:
            candidates.append({"days": 0, "msg": "已達第一款連續3天 -> 進處置", "type": "C1", "prob": 100})
        elif needed_c1 < 3 and needed_c1 <= future_days:
             # Construct message
             if needed_c1 == 1:
                 msg = "明天第一款則進處置"
             else:
                 msg = f"接下來連續{needed_c1}天第一款則進處置"
             # Prob: Progress based (3 - needed) / 3
             p = int(((3 - needed_c1) / 3) * 100)
             candidates.append({"days": needed_c1, "msg": msg, "type": "C1", "prob": p})
                 
        # Rule 2: Consecutive 5 days Any Clause
        streak_any = 0
        for i in range(len(H)-1, -1, -1):
            if H[i]["any"]: streak_any += 1
            else: break
            
        needed_any = 5 - streak_any
        if needed_any <= 0:
             candidates.append({"days": 0, "msg": "已達連續5天注意 -> 進處置", "type": "Any", "prob": 100})
        elif needed_any < 5 and needed_any <= future_days:
             if needed_any == 1:
                 msg = "明天一至八款則進處置"
             else:
                 msg = f"接下來連續{needed_any}天一至八款則進處置"
             # Prob: Progress based (5 - needed) / 5
             p = int(((5 - needed_any) / 5) * 100)
             candidates.append({"days": needed_any, "msg": msg, "type": "Any", "prob": p})

        # Rule 3: 6 days in 10 days (Any Clause)
        # Scan future days 1..x
        for x in range(1, future_days + 1):
             slice_start = -10 + x
             if slice_start >= 0:
                 hist_slice = H[slice_start:] 
             else:
                 hist_slice = H[slice_start:]
                 
             base_count = sum(1 for item in hist_slice if item["any"])
             needed = 6 - base_count
             
             if needed <= x:
                 hits_req = max(1, needed)
                 
                 # Phrasing
                 if hits_req == x:
                     if x == 1:
                         msg = "明天一至八款則進處置"
                     else:
                         msg = f"接下來連續{x}天一至八款則進處置"
                 else:
                     msg = f"接下來{x}天 有{hits_req}天一至八款則進處置"
                 
                 # Prob: Tolerance based (Window - Needed) / Window
                 # If hits_req == x (Consecutive requirement in window), prob is 0% by tolerance formula.
                 # But user might validly see this as "High Risk" if x is small?
                 # No, stick to tolerance formula for Rule 3 as it represents "slack".
                 # (x - hits_req) / x
                 p = int(((x - hits_req) / x) * 100)
                 
                 candidates.append({"days": x, "msg": msg, "type": "Any", "prob": p})

        # --- Filtering Logic ---
        # 1. Check for "Already" (Days <= 0)

class DispositionPredictor:
    @staticmethod
    def analyze(history_items, future_days=5):
        """
        history_items: list of dict [{"is_clause1": bool, "is_any": bool}, ...] 
                       Current day is LAST item.
        future_days: number of future days to simulate (e.g. 5)
        
        Returns: Warning string
        """
        if not history_items: return ""
        
        # Normalize Data
        H = []
        has_any_hit = False
        for item in history_items:
            c1 = item.get("is_clause1", False)
            any_c = item.get("is_any", False)
            if c1 or any_c: has_any_hit = True
            H.append({ "c1": c1, "any": any_c })
            
        # If no hits in entire history, prediction is just "If you start today...", which is noise.
        # Unless the user wants to know they are safe? Default is silent.
        # But wait, Rule 3 uses a 10-day window. If history is [0,0,0], Base=0. Next 6 days trigger.
        # User implies this is spam.
        if not has_any_hit:
            return ("", 0)

        candidates = [] # List of {"days": int, "msg": str, "type": "C1"|"Any"}
        
        # Rule 1: Consecutive 3 days Clause 1
        streak_c1 = 0
        for i in range(len(H)-1, -1, -1):
            if H[i]["c1"]: streak_c1 += 1
            else: break
            
        needed_c1 = 3 - streak_c1
        if needed_c1 <= 0:
            candidates.append({"days": 0, "msg": "已達第一款連續3天 -> 進處置", "type": "C1", "prob": 100})
        elif needed_c1 < 3 and needed_c1 <= future_days:
             # Construct message
             if needed_c1 == 1:
                 msg = "明天第一款則進處置"
             else:
                 msg = f"接下來連續{needed_c1}天第一款則進處置"
             # Prob: Progress based (3 - needed) / 3
             p = int(((3 - needed_c1) / 3) * 100)
             candidates.append({"days": needed_c1, "msg": msg, "type": "C1", "prob": p})
                 
        # Rule 2: Consecutive 5 days Any Clause
        streak_any = 0
        for i in range(len(H)-1, -1, -1):
            if H[i]["any"]: streak_any += 1
            else: break
            
        needed_any = 5 - streak_any
        if needed_any <= 0:
             candidates.append({"days": 0, "msg": "已達連續5天注意 -> 進處置", "type": "Any", "prob": 100})
        elif needed_any < 5 and needed_any <= future_days:
             if needed_any == 1:
                 msg = "明天一至八款則進處置"
             else:
                 msg = f"接下來連續{needed_any}天一至八款則進處置"
             # Prob: Progress based (5 - needed) / 5
             p = int(((5 - needed_any) / 5) * 100)
             candidates.append({"days": needed_any, "msg": msg, "type": "Any", "prob": p})

        # Rule 3: 6 days in 10 days (Any Clause)
        # Scan future days 1..x
        for x in range(1, future_days + 1):
             slice_start = -10 + x
             if slice_start >= 0:
                 hist_slice = H[slice_start:] 
             else:
                 hist_slice = H[slice_start:]
                 
             base_count = sum(1 for item in hist_slice if item["any"])
             needed = 6 - base_count
             
             if needed <= x:
                 hits_req = max(1, needed)
                 
                 # Phrasing
                 if hits_req == x:
                     if x == 1:
                         msg = "明天一至八款則進處置"
                     else:
                         msg = f"接下來連續{x}天一至八款則進處置"
                 else:
                     msg = f"接下來{x}天 有{hits_req}天一至八款則進處置"
                 
                 # Prob: Tolerance based (Window - Needed) / Window
                 # If hits_req == x (Consecutive requirement in window), prob is 0% by tolerance formula.
                 # But user might validly see this as "High Risk" if x is small?
                 # No, stick to tolerance formula for Rule 3 as it represents "slack".
                 # (x - hits_req) / x
                 p = int(((x - hits_req) / x) * 100)
                 
                 candidates.append({"days": x, "msg": msg, "type": "Any", "prob": p})

        # --- Filtering Logic ---
        # 1. Check for "Already" (Days <= 0)
        already_candidates = [c for c in candidates if c["days"] <= 0]
        if already_candidates:
            msgs = sorted(list(set(c["msg"] for c in already_candidates)))
            return ("\n".join(msgs), 100)
            
        # 2. Future Predictions
        # Strategy: Show the Earliest Warning (Best Timeline) AND Highest Risk Warning (Best Prob)
        selected_candidates = []
        
        for type_key in ["C1", "Any"]:
            type_cands = [c for c in candidates if c["type"] == type_key]
            if not type_cands: continue
            
            # Find Min Days (Earliest)
            min_days = min(c["days"] for c in type_cands)
            earliest_cands = [c for c in type_cands if c["days"] == min_days]
            selected_candidates.extend(earliest_cands)
            
            # Find Max Prob (Highest Risk)
            max_p = max(c["prob"] for c in type_cands)
            # Only add if it offers a significantly higher probability than the earliest one?
            # Or just add it.
            # If Earliest has Prob 0, and Later has Prob 60, we definitely want the Later one.
            risk_cands = [c for c in type_cands if c["prob"] == max_p]
            selected_candidates.extend(risk_cands)

        # Deduplicate by Message
        unique_msgs = set()
        final_objs = []
        
        # Sort selection by Days Asc, then Prob Desc
        selected_candidates.sort(key=lambda x: (x["days"], -x["prob"]))
        
        for c in selected_candidates:
            if c["msg"] not in unique_msgs:
                unique_msgs.add(c["msg"])
                final_objs.append(c)
        
        if not final_objs:
            return ("", 0)
            
        final_msgs = [c["msg"] for c in final_objs]
        max_prob = max(c["prob"] for c in final_objs) if final_objs else 0
        
        return ("\n".join(final_msgs), max_prob)
